/*jslint node: true */

'use strict';
// Require Gulp first
var gulp = require('gulp'),
//  packageJson = require('./package.json'),
// Load plugins
  $ = require('gulp-load-plugins')(),
// SASS and sourcemaps
  sass = require('gulp-ruby-sass'),
  sourcemaps = require('gulp-sourcemaps'),
// Javascript
  jshint = require('gulp-jshint'),
// Image Processing
  imagemin = require('gulp-imagemin'),
// Cleanup Crew
  del = require('del'),
// Static Web Server stuff
  browserSync = require('browser-sync'),
  reload = browserSync.reload,
  historyApiFallback = require('connect-history-api-fallback');

//var key = '';
var site = 'https://caraya.github.io/athena-template/';

// List of browser versions we'll autoprefix for. 
// Taken from the Polymer Starter Kit gulpfile
var AUTOPREFIXER_BROWSERS = [
    'ie >= 10',
    'ie_mob >= 10',
    'ff >= 30',
    'chrome >= 34',
    'safari >= 7',
    'opera >= 23',
    'ios >= 7',
    'android >= 4.4',
    'bb >= 10'
  ];

// Transpiles ES6 to ES5 using Babel
gulp.task('babel', function () {
  return gulp.src('app/es6/**/*.js')
    .pipe($.sourcemaps.init())
    .pipe($.babel({
      presets: ['es2015']
    }))
    .pipe($.sourcemaps.write('.'))
    .pipe(gulp.dest('app/js/'))
    .pipe($.size({
      pretty: true,
      title: 'Babel'
    }));
});

// Transpiles Coffeescript to ES5
gulp.task('coffee', function () {
  gulp.src('app/coffee/**/*.coffee')
    .pipe($.sourcemaps.init())
    .pipe($.coffee())
    .pipe($.sourcemaps.write())
    .pipe(gulp.dest('app/js/'))
      .pipe($.size({
      pretty: true,
      title: 'Coffee'
    }));
});

// EXPERIMENTAL TYPESCRIPT SUPPORT
// Not sure I want to keep it so be warned
// uses gulp-typescript, gulp-tslint and tslint (peer dep of gulp-tslint)
gulp.task('typescript', function () {
  return gulp.src('app/ts/**/*.ts')
    .pipe($.ts({
      noImplicitAny: true,
      out: 'scripts-ts.js',
      target: 'es5'
    }))
    .pipe($.tslint())
    .pipe($.tslint.report("verbose", { emitError: false }))
    .pipe(gulp.dest('app/js'));
});

// Javascript style and syntax validation
// RUN THE TASK BELOW AFTER TRANSPILING ES6, TYPESCRIPT AND COFFEE FILES

// Run JSHint in all js files, including the gulpfile and 
// all files under js
gulp.task('js-lint', function () {
  return gulp.src(['gulpfile.js', 'app/js/**/*.js'])
    .pipe(jshint())
    .pipe(jshint.reporter('jshint-stylish'));
});

//Run jscs on all file under js
gulp.task('js-style', function () {
  return gulp.src(['app/js/**/*.js'])
    .pipe($.jscs())
    .pipe($.jscs.reporter())
    .pipe($.size({
      pretty: true,
      title: 'jscs'
    }));
});

// SCSS conversion and CSS processing
gulp.task('sass:dev', function () {
  return sass('app/scss/**/*.scss', { sourcemap: true, style: 'expanded'})
    .pipe(gulp.dest('app/css/expanded'))
    .pipe($.size({
      pretty: true,
      title: 'SASS'
    }));
});

gulp.task('sass:production', function () {
  return sass('app/scss/**/*.scss', { sourcemap: true, style: 'compressed'})
    .pipe(gulp.dest('app/css/expanded'))
    .pipe($.size({
      pretty: true,
      title: 'SASS'
    }));
});

// Run autoprefixer and cssnano in the css generated by sass
// The versions of browsers to run autoprefixer against are 
// defined in the variable AUTOPREFIXER_BROWSERS
gulp.task('processCSS', function () {
  return gulp.src('app/css/**/*.css')
    .pipe($.changed('app/css/**/*.css', {extension: '.css'}))
    .pipe($.autoprefixer(AUTOPREFIXER_BROWSERS))
    .pipe(sourcemaps.init())
    .pipe($.cssnano({autoprefixer: false}))
    .pipe(sourcemaps.write('.'))
    .pipe(gulp.dest('dist/css'))
    .pipe($.size({
      pretty: true,
      title: 'processCSS'
    }));
});

// Taking a css and an html file, UNCC will strip all CSS selectors 
// not used in the page
gulp.task('uncss', function () {
  return gulp.src('app/css/**/*.css')
    .pipe($.concat('main.css'))
    .pipe($.uncss({
      html: ['index.html']
    }))
    .pipe(gulp.dest('dist/css/all-clean.css'))
    .pipe($.size({
      pretty: true,
      title: 'Uncss'
    }));
});

// Parse build blocks in HTML files to replace references to non-optimized 
// scripts or stylesheets.
gulp.task('useref', function () {
  return gulp.src('app/*.html')
    .pipe($.useref({ searchPath: '.tmp' }))
    .pipe(gulp.dest('dist/*.html'));
});

/* Generates inline css for the css critical path */
gulp.task('critical', function () {
  $.critical.generate({
    base: 'app/',
    src: 'index.html',
    css: ['css/main.css'],
    dimensions: [{
      width: 320,
      height: 480
    }, {
      width: 768,
      height: 1024
    }, {
      width: 1280,
      height: 960
    }],
    dest: 'app/css/critical.css',
    minify: true,
    extract: false,
    ignore: ['font-face']
  })
  
    .pipe($.size({
      pretty: true,
      title: 'Critical'
    }));
});

// Performance check using Google Page Speed Insight
// Use the `nokey` option to try out PageSpeed Insights as part of your 
// build process. For more frequent use, we recommend registering for your 
// own API key. For more info: 
// https://developers.google.com/speed/docs/insights/v2/getting-started
//
// We do separate tests for mobile and desktop.
gulp.task('psi-mobile', function () {
  return $.psi(site, {
    // key: key
    nokey: 'true',
    strategy: 'mobile'
  }).then(function (data) {
    console.log('Speed score: ' + data.ruleGroups.SPEED.score);
    console.log('Usability score: ' + data.ruleGroups.USABILITY.score);
  });
});

gulp.task('psi-desktop', function () {
  return $.psi(site, {
    nokey: 'true',
    // key: key,
    strategy: 'desktop'
  }).then(function (data) {
    console.log('Speed score: ' + data.ruleGroups.SPEED.score);
  });
});

// Image manipulation
// Reduces image file sizes. Doubly important if we'll choose to play 
// with responsive images. 
//
// Imagemin will compress jpg (using mozilla's mozjpeg), SVG (using SVGO)
// GIF and PNG images but WILL NOT create multiple versions for use with
// responsive images (see process-images task below)
gulp.task('imagemin', function () {
  return gulp.src('app/images/**/*')
    .pipe(imagemin({
      progressive: true,
      svgoPlugins: [{removeViewBox: false}],
      use: [$.mozjpeg()]
    }))
    .pipe(gulp.dest('dist/images'))
    .pipe($.size({
      pretty: true,
      title: 'imagemin'
    }));
});

// process-images combines a responsive-image generation task with imagemin 
// but will only work with JPG and PNG images (you don't need to generate 
// optimized SVG and GIF is useless at larger resolutions.)
//
// I'm keeping imagemin as a separate task because there may be times when I 
// only want to compress images without generating multiple versions of them
gulp.task('process-images', function () {
  return gulp.src('src/*.{jpg,png}')
    .pipe($.responsive({
      'image.*': [{
        // image-small.jpg is 200 pixels wide
        width: 200,
        rename: {
          suffix: '-small',
          extname: '.jpg'
        }
      }, {
        // image-small@2x.jpg is 400 pixels wide
        width: 200 * 2,
        rename: {
          suffix: '-small@2x',
          extname: '.jpg'
        }
      }, {
        // image-large.jpg is 480 pixels wide
        width: 480,
        rename: {
          suffix: '-large',
          extname: '.jpg'
        }
      }, {
        // image-large@2x.jpg is 960 pixels wide
        width: 480 * 2,
        rename: {
          suffix: '-large@2x',
          extname: '.jpg'
        }
      }, {
        // image-extralarge.jpg is 1280 pixels wide
        width: 1280,
        rename: {
          suffix: '-extralarge',
          extname: '.jpg'
        }
      }, {
        // image-extralarge@2x.jpg is 2560 pixels wide
        width: 1280 * 2,
        rename: {
          suffix: '-extralarge@2x',
          extname: '.jpg'
        }
      }, {
        // image-small.webp is 200 pixels wide
        width: 200,
        rename: {
          suffix: '-small',
          extname: '.webp'
        }
      }, {
        // image-small@2x.webp is 400 pixels wide
        width: 200 * 2,
        rename: {
          suffix: '-small@2x',
          extname: '.webp'
        }
      }, {
        // image-large.webp is 480 pixels wide
        width: 480,
        rename: {
          suffix: '-large',
          extname: '.webp'
        }
      }, {
        // image-large@2x.webp is 960 pixels wide
        width: 480 * 2,
        rename: {
          suffix: '-large@2x',
          extname: '.webp'
        }
      }, {
        // image-extralarge.webp is 1280 pixels wide
        width: 1280,
        rename: {
          suffix: '-extralarge',
          extname: '.webp'
        }
      }, {
        // image-extralarge@2x.webp is 2560 pixels wide
        width: 1280 * 2,
        rename: {
          suffix: '-extralarge@2x',
          extname: '.webp'
        }
      }]
    }))
    .pipe($.imagemin({
      progressive: true,
      svgoPlugins: [{removeViewBox: false}],
      use: [ $.mozjpeg() ]
    }))
    .pipe($.imageminWebp({quality: 50})())
    .pipe(gulp.dest('dist/images'))
    .pipe($.size({
      pretty: true,
      title: 'processImages'
    }));
});

// Vulcanize and Crisper are Polymer specific tasks
// 
// Vulcanize will combine all elements in elements.html and produce a single file.
// This is the same as a concatenate task except that it understands polymer idiosyncracies
// 
// We run crisper in the vulcanized output to extract scripts so we comply with CSP.
gulp.task('polymerBuild', function () {
  return gulp.src('app/elements/elements.html')
    .pipe($.vulcanize({
      stripComments: false,
      inlineCss: true,
      inlineScripts: true
    }))
    .pipe($.crisper({
      scriptInHead: false, // true is default 
      onlySplit: false
    }))
    .pipe(gulp.dest('dist/elements'))
    .pipe($.size({title: 'vulcanize'}));
});

// Copy all files at the root level (app)
gulp.task('copy', function () {
  var app, bower;

  app = gulp.src([
    'app/*',
    '!app/coffee',
    '!app/es6',
    '!app/scss',
    '!app/test',
    '!app/bower_components',
    '!app/cache-config.json',
    '!**/.DS_Store'
  ], {
    dot: true
  }).pipe(gulp.dest('dist'));

  // Copy over only the bower_components we need
  // These are things which cannot be vulcanized
  bower = gulp.src([
    'bower_components/{webcomponentsjs,platinum-sw,sw-toolbox,promise-polyfill}/**/*'
  ])
    .pipe(gulp.dest('dist/elements'))
    .pipe($.size({
      pretty: true,
      title: 'copy'
    }));
});

// Copy web fonts to dist
gulp.task('fonts', function () {
  return gulp.src(['app/fonts/**'])
    .pipe(gulp.dest('dist/fonts/'))
    .pipe($.size({
      title: 'fonts'
    }));
});

// Clean output directory
gulp.task('clean', function () {
  return del(['.tmp', 'dist/'])
    .pipe($.size({
      title: 'clean'
    }));
});

// Deploys the content from dist/ into the repository's gh-pages branch
// 
// We do this so we can take advantage of HTTPs in gh-pages. If you're deploying
// to different servers you're on your own :-)
gulp.task('deploy', function () {
  return gulp.src('./dist/**/*')
    .pipe($.ghPages())
    .pipe($.size({
      title: 'deploy'
    }));
});

// Watch files for changes & reload
// This version serves content from the app source directory
gulp.task('serve', function () {
  browserSync({
    port: 2509,
    notify: false,
    logPrefix: 'ATHENA',
    snippetOptions: {
      rule: {
        match: '<span id="browser-sync-binding"></span>',
        fn: function (snippet) {
          return snippet;
        }
      }
    },
    // Run as an https by uncommenting 'https: true'
    // Note: this uses an unsigned certificate which on first access
    //       will present a certificate warning in the browser.
    // https: true,
    server: {
      baseDir: ['.tmp', 'app'],
      middleware: [historyApiFallback()]
    }
  });

  gulp.watch(['app/**/*.html'], reload);
  gulp.watch(['app/css/**/*.scss'], ['sass', 'processCSS', reload]);
  gulp.watch(['app/images/**/*'], reload);
});

// Build and serve the output from the dist build
gulp.task('serve:dist', function () {
  browserSync({
    port: 5001,
    notify: false,
    logPrefix: 'ATHENA',
    snippetOptions: {
      rule: {
        match: '<span id="browser-sync-binding"></span>',
        fn: function (snippet) {
          return snippet;
        }
      }
    },
    // Run as an https by uncommenting 'https: true'
    // Note: this uses an unsigned certificate which on first access
    //       will present a certificate warning in the browser.
    // https: true,
    server: 'dist/',
    middleware: [historyApiFallback()]
  });
});

gulp.task('prep', ['clean', 'copy', 'fonts', 'processImages']);
//gulp.task('default', ['sass']);
